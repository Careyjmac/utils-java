// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: google/genomics/v1/readalignment.proto

package com.google.genomics.v1;

public interface ReadOrBuilder extends
    // @@protoc_insertion_point(interface_extends:google.genomics.v1.Read)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <code>optional string id = 1;</code>
   *
   * <pre>
   * The unique ID for this read. This is a generated unique ID, not to be
   * confused with fragmentName.
   * </pre>
   */
  java.lang.String getId();
  /**
   * <code>optional string id = 1;</code>
   *
   * <pre>
   * The unique ID for this read. This is a generated unique ID, not to be
   * confused with fragmentName.
   * </pre>
   */
  com.google.protobuf.ByteString
      getIdBytes();

  /**
   * <code>optional string read_group_id = 2;</code>
   *
   * <pre>
   * The ID of the read group this read belongs to.
   * (Every read must belong to exactly one read group.)
   * </pre>
   */
  java.lang.String getReadGroupId();
  /**
   * <code>optional string read_group_id = 2;</code>
   *
   * <pre>
   * The ID of the read group this read belongs to.
   * (Every read must belong to exactly one read group.)
   * </pre>
   */
  com.google.protobuf.ByteString
      getReadGroupIdBytes();

  /**
   * <code>optional string read_group_set_id = 3;</code>
   *
   * <pre>
   * The ID of the read group set this read belongs to.
   * (Every read must belong to exactly one read group set.)
   * </pre>
   */
  java.lang.String getReadGroupSetId();
  /**
   * <code>optional string read_group_set_id = 3;</code>
   *
   * <pre>
   * The ID of the read group set this read belongs to.
   * (Every read must belong to exactly one read group set.)
   * </pre>
   */
  com.google.protobuf.ByteString
      getReadGroupSetIdBytes();

  /**
   * <code>optional string fragment_name = 4;</code>
   *
   * <pre>
   * The fragment name. Equivalent to QNAME (query template name) in SAM.
   * </pre>
   */
  java.lang.String getFragmentName();
  /**
   * <code>optional string fragment_name = 4;</code>
   *
   * <pre>
   * The fragment name. Equivalent to QNAME (query template name) in SAM.
   * </pre>
   */
  com.google.protobuf.ByteString
      getFragmentNameBytes();

  /**
   * <code>optional bool proper_placement = 5;</code>
   *
   * <pre>
   * The orientation and the distance between reads from the fragment are
   * consistent with the sequencing protocol (SAM flag 0x2)
   * </pre>
   */
  boolean getProperPlacement();

  /**
   * <code>optional bool duplicate_fragment = 6;</code>
   *
   * <pre>
   * The fragment is a PCR or optical duplicate (SAM flag 0x400)
   * </pre>
   */
  boolean getDuplicateFragment();

  /**
   * <code>optional int32 fragment_length = 7;</code>
   *
   * <pre>
   * The observed length of the fragment, equivalent to TLEN in SAM.
   * </pre>
   */
  int getFragmentLength();

  /**
   * <code>optional int32 read_number = 8;</code>
   *
   * <pre>
   * The read number in sequencing. 0-based and less than numberReads. This
   * field replaces SAM flag 0x40 and 0x80.
   * </pre>
   */
  int getReadNumber();

  /**
   * <code>optional int32 number_reads = 9;</code>
   *
   * <pre>
   * The number of reads in the fragment (extension to SAM flag 0x1).
   * </pre>
   */
  int getNumberReads();

  /**
   * <code>optional bool failed_vendor_quality_checks = 10;</code>
   *
   * <pre>
   * SAM flag 0x200
   * </pre>
   */
  boolean getFailedVendorQualityChecks();

  /**
   * <code>optional .google.genomics.v1.LinearAlignment alignment = 11;</code>
   *
   * <pre>
   * The linear alignment for this alignment record. This field will be
   * null if the read is unmapped.
   * </pre>
   */
  boolean hasAlignment();
  /**
   * <code>optional .google.genomics.v1.LinearAlignment alignment = 11;</code>
   *
   * <pre>
   * The linear alignment for this alignment record. This field will be
   * null if the read is unmapped.
   * </pre>
   */
  com.google.genomics.v1.LinearAlignment getAlignment();
  /**
   * <code>optional .google.genomics.v1.LinearAlignment alignment = 11;</code>
   *
   * <pre>
   * The linear alignment for this alignment record. This field will be
   * null if the read is unmapped.
   * </pre>
   */
  com.google.genomics.v1.LinearAlignmentOrBuilder getAlignmentOrBuilder();

  /**
   * <code>optional bool secondary_alignment = 12;</code>
   *
   * <pre>
   * Whether this alignment is secondary. Equivalent to SAM flag 0x100.
   * A secondary alignment represents an alternative to the primary alignment
   * for this read. Aligners may return secondary alignments if a read can map
   * ambiguously to multiple coordinates in the genome. By convention, each read
   * has one and only one alignment where both `secondaryAlignment`
   * and `supplementaryAlignment` are false.
   * </pre>
   */
  boolean getSecondaryAlignment();

  /**
   * <code>optional bool supplementary_alignment = 13;</code>
   *
   * <pre>
   * Whether this alignment is supplementary. Equivalent to SAM flag 0x800.
   * Supplementary alignments are used in the representation of a chimeric
   * alignment. In a chimeric alignment, a read is split into multiple
   * linear alignments that map to different reference contigs. The first
   * linear alignment in the read will be designated as the representative
   * alignment; the remaining linear alignments will be designated as
   * supplementary alignments. These alignments may have different mapping
   * quality scores. In each linear alignment in a chimeric alignment, the read
   * will be hard clipped. The `alignedSequence` and
   * `alignedQuality` fields in the alignment record will only
   * represent the bases for its respective linear alignment.
   * </pre>
   */
  boolean getSupplementaryAlignment();

  /**
   * <code>optional string aligned_sequence = 14;</code>
   *
   * <pre>
   * The bases of the read sequence contained in this alignment record,
   * *without CIGAR operations applied*.
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   * </pre>
   */
  java.lang.String getAlignedSequence();
  /**
   * <code>optional string aligned_sequence = 14;</code>
   *
   * <pre>
   * The bases of the read sequence contained in this alignment record,
   * *without CIGAR operations applied*.
   * `alignedSequence` and `alignedQuality` may be
   * shorter than the full read sequence and quality. This will occur if the
   * alignment is part of a chimeric alignment, or if the read was trimmed. When
   * this occurs, the CIGAR for this read will begin/end with a hard clip
   * operator that will indicate the length of the excised sequence.
   * </pre>
   */
  com.google.protobuf.ByteString
      getAlignedSequenceBytes();

  /**
   * <code>repeated int32 aligned_quality = 15;</code>
   *
   * <pre>
   * The quality of the read sequence contained in this alignment record.
   * `alignedSequence` and `alignedQuality` may be shorter
   * than the full read sequence and quality. This will occur if the alignment
   * is part of a chimeric alignment, or if the read was trimmed. When this
   * occurs, the CIGAR for this read will begin/end with a hard clip operator
   * that will indicate the length of the excised sequence.
   * </pre>
   */
  java.util.List<java.lang.Integer> getAlignedQualityList();
  /**
   * <code>repeated int32 aligned_quality = 15;</code>
   *
   * <pre>
   * The quality of the read sequence contained in this alignment record.
   * `alignedSequence` and `alignedQuality` may be shorter
   * than the full read sequence and quality. This will occur if the alignment
   * is part of a chimeric alignment, or if the read was trimmed. When this
   * occurs, the CIGAR for this read will begin/end with a hard clip operator
   * that will indicate the length of the excised sequence.
   * </pre>
   */
  int getAlignedQualityCount();
  /**
   * <code>repeated int32 aligned_quality = 15;</code>
   *
   * <pre>
   * The quality of the read sequence contained in this alignment record.
   * `alignedSequence` and `alignedQuality` may be shorter
   * than the full read sequence and quality. This will occur if the alignment
   * is part of a chimeric alignment, or if the read was trimmed. When this
   * occurs, the CIGAR for this read will begin/end with a hard clip operator
   * that will indicate the length of the excised sequence.
   * </pre>
   */
  int getAlignedQuality(int index);

  /**
   * <code>optional .google.genomics.v1.Position next_mate_position = 16;</code>
   *
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   */
  boolean hasNextMatePosition();
  /**
   * <code>optional .google.genomics.v1.Position next_mate_position = 16;</code>
   *
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   */
  com.google.genomics.v1.Position getNextMatePosition();
  /**
   * <code>optional .google.genomics.v1.Position next_mate_position = 16;</code>
   *
   * <pre>
   * The mapping of the primary alignment of the
   * `(readNumber+1)%numberReads` read in the fragment. It replaces
   * mate position and mate strand in SAM.
   * </pre>
   */
  com.google.genomics.v1.PositionOrBuilder getNextMatePositionOrBuilder();

  /**
   * <code>map&lt;string, .google.protobuf.ListValue&gt; info = 17;</code>
   *
   * <pre>
   * A map of additional read alignment information. This must be of the form
   * map&lt;string, string[]&gt; (string key mapping to a list of string values).
   * </pre>
   */
  java.util.Map<java.lang.String, com.google.protobuf.ListValue>
  getInfo();
}
